/*
--------------------------------------------------------------------
XXXX           PYTEMPLATE AUTOMATICALLY GENERATED FILE          XXXX

        version 0.01                                                
        Generated 2015-02-21 18:15:24.608000
        
XXXX    DO NOT EDIT THIS FILE                                   XXXX
--------------------------------------------------------------------
*/package evans.dave.androtag.app;

/**
 * Created by Dave on 09/02/2015.
 */


import android.content.Context;
import android.util.Log;
import android.widget.Toast;

import java.util.LinkedList;

import evans.dave.androtag.common.SerialMessage;

import static evans.dave.androtag.common.SerialMessage.*;

public abstract class SerialManager {

    protected static LinkedList<Byte> inBuffer = new LinkedList<>();
    private static Context ctx;

	/* Generate code like this:
    abstract void setShield(int a0, int a1, int a2, int a3);
	*/

    abstract void runPacket(int a0, int a1, int a2, int a3);



    public SerialManager(Context ctx){
        this.ctx = ctx;
    }

    protected void addDataCallback(byte[] data){
        // Add the data
        for (byte b: data){
            if (FLUSH.equals(b))
                inBuffer.clear();
            else
                inBuffer.addLast(b);
        }

        parseMessages();

    }

    protected boolean parseMessages(){
        SerialMessage startCode;
        byte[] packet = new byte[4];
        while (inBuffer.size()>=4){

            // Get the packet

            for (int i = 0; i < 4; i++)
                packet[i] = inBuffer.removeFirst();

            startCode = SerialMessage.getFromByte(packet[0]);

            if (startCode == null){
                // Not a known message
                // Todo: Throw an exception and flush buffer
                return false;
            }

            runPacket(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));

        }
        return true; //Queue is empty
    }

    private byte[] parsePacket(int num){
        if (inBuffer.size()>=num) {
            byte[] data = new byte[num];

            for (int i = 0; i < num; i++)
                data[i] = inBuffer.removeFirst();
            return data;
        } else {
            return null; // Not enough data, return null
        }
    }

    protected int toInt(byte b){
        return (int) b & 0xFF;
    }


}
