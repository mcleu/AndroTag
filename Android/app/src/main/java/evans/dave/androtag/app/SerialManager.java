/*
--------------------------------------------------------------------
XXXX           PYTEMPLATE AUTOMATICALLY GENERATED FILE          XXXX

        version 0.01                                                
        Generated 2015-02-21 18:15:24.608000
        
XXXX    DO NOT EDIT THIS FILE                                   XXXX
--------------------------------------------------------------------
*/package evans.dave.androtag.app;

/**
 * Created by Dave on 09/02/2015.
 */


import android.content.Context;
import android.util.Log;
import android.widget.Toast;

import java.util.LinkedList;

import evans.dave.androtag.common.SerialMessage;

import static evans.dave.androtag.common.SerialMessage.*;

public abstract class SerialManager {

    protected static LinkedList<Byte> inBuffer = new LinkedList<>();
    private static Context ctx;

	/* Generate code like this:
    abstract void setShield(int a0, int a1, int a2, int a3);
	*/
	
	
/* AUTO CODE BEGIN */

    abstract void setState(int a0, int a1, int a2, int a3);
    abstract void setLives(int a0, int a1, int a2, int a3);
    abstract void setShield(int a0, int a1, int a2, int a3);
    abstract void setRespawn(int a0, int a1, int a2, int a3);
    abstract void setPid(int a0, int a1, int a2, int a3);
    abstract void setTid(int a0, int a1, int a2, int a3);
    abstract void setGid(int a0, int a1, int a2, int a3);
    abstract void setColor(int a0, int a1, int a2, int a3);
    abstract void addEnemy(int a0, int a1, int a2, int a3);
    abstract void clearEnemies(int a0, int a1, int a2, int a3);
    abstract void setNumGuns(int a0, int a1, int a2, int a3);
    abstract void setGun0(int a0, int a1, int a2, int a3);
    abstract void setGun1(int a0, int a1, int a2, int a3);
    abstract void setGun2(int a0, int a1, int a2, int a3);
    abstract void setGun3(int a0, int a1, int a2, int a3);
    abstract void tryFire(int a0, int a1, int a2, int a3);
    abstract void fireSuccess(int a0, int a1, int a2, int a3);
    abstract void tryReload(int a0, int a1, int a2, int a3);
    abstract void reloadSuccess(int a0, int a1, int a2, int a3);
    abstract void setAmmo(int a0, int a1, int a2, int a3);
    abstract void setActive(int a0, int a1, int a2, int a3);
    abstract void noLives(int a0, int a1, int a2, int a3);
    abstract void hitBy(int a0, int a1, int a2, int a3);
    abstract void killedBy(int a0, int a1, int a2, int a3);
    abstract void setStartTime(int a0, int a1, int a2, int a3);
    abstract void setEndTime(int a0, int a1, int a2, int a3);
    abstract void endGame(int a0, int a1, int a2, int a3);
    abstract void ack(int a0, int a1, int a2, int a3);
    abstract void flush(int a0, int a1, int a2, int a3);
	
/* AUTO CODE END */



    public SerialManager(Context ctx){
        this.ctx = ctx;
    }

    protected void addDataCallback(byte[] data){
        // Add the data
        for (byte b: data){
            if (FLUSH.equals(b))
                inBuffer.clear();
            else
                inBuffer.addLast(b);
        }

        parseMessages();

    }

    protected boolean parseMessages(){
        SerialMessage startCode;
        byte[] packet = new byte[4];
        while (inBuffer.size()>=4){

            // Get the packet

            for (int i = 0; i < 4; i++)
                packet[i] = inBuffer.removeFirst();

            startCode = SerialMessage.getFromByte(packet[0]);

            if (startCode == null){
                // Not a known message
                // Todo: Throw an exception and flush buffer
                return false;
            }

            switch (startCode){
/* AUTO CODE BEGIN */

                case SET_STATE:
                    setState(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_LIVES:
                    setLives(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_SHIELD:
                    setShield(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_RESPAWN:
                    setRespawn(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_PID:
                    setPid(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_TID:
                    setTid(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_GID:
                    setGid(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_COLOR:
                    setColor(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case ADD_ENEMY:
                    addEnemy(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case CLEAR_ENEMIES:
                    clearEnemies(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_NUM_GUNS:
                    setNumGuns(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_GUN_0:
                    setGun0(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_GUN_1:
                    setGun1(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_GUN_2:
                    setGun2(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_GUN_3:
                    setGun3(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case TRY_FIRE:
                    tryFire(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case FIRE_SUCCESS:
                    fireSuccess(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case TRY_RELOAD:
                    tryReload(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case RELOAD_SUCCESS:
                    reloadSuccess(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_AMMO:
                    setAmmo(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_ACTIVE:
                    setActive(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case NO_LIVES:
                    noLives(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case HIT_BY:
                    hitBy(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case KILLED_BY:
                    killedBy(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_START_TIME:
                    setStartTime(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case SET_END_TIME:
                    setEndTime(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case END_GAME:
                    endGame(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case ACK:
                    ack(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

                case FLUSH:
                    flush(toInt(packet[0]), toInt(packet[1]),toInt(packet[2]),toInt(packet[3]));
                    break;

/* AUTO CODE END */
                default:
                    return false;
            }


        }
        return true; //Queue is empty
    }

    private byte[] parsePacket(int num){
        if (inBuffer.size()>=num) {
            byte[] data = new byte[num];

            for (int i = 0; i < num; i++)
                data[i] = inBuffer.removeFirst();
            return data;
        } else {
            return null; // Not enough data, return null
        }
    }

    protected int toInt(byte b){
        return (int) b & 0xFF;
    }


}
