/*
--------------------------------------------------------------------
XXXX           PYTEMPLATE AUTOMATICALLY GENERATED FILE          XXXX

        version 0.01                                                
        Generated 2015-02-21 18:15:24.608000
        
XXXX    DO NOT EDIT THIS FILE                                   XXXX
--------------------------------------------------------------------
*/package evans.dave.androtag.app;

/**
 * Created by Dave on 09/02/2015.
 */


import android.content.Context;
import android.util.Log;
import android.widget.Toast;

import java.util.LinkedList;

import evans.dave.androtag.common.SerialMessage;

import static evans.dave.androtag.common.SerialMessage.*;

public abstract class SerialManager {

    private static LinkedList<Byte> inBuffer = new LinkedList<>();
    private static Context ctx;

	/* Generate code like this:
    abstract void setShield(int a0, int a1, int a2, int a3);
	*/
	
	
/* AUTO CODE BEGIN */

	abstract void setState(int a0, int a1, int a2, int a3);
	abstract void setLives(int a0, int a1, int a2, int a3);
	abstract void setShield(int a0, int a1, int a2, int a3);
	abstract void setRespawn(int a0, int a1, int a2, int a3);
	abstract void setPid(int a0, int a1, int a2, int a3);
	abstract void setTid(int a0, int a1, int a2, int a3);
	abstract void setGid(int a0, int a1, int a2, int a3);
	abstract void setColor(int a0, int a1, int a2, int a3);
	abstract void addEnemy(int a0, int a1, int a2, int a3);
	abstract void clearEnemies(int a0, int a1, int a2, int a3);
	abstract void setNumGuns(int a0, int a1, int a2, int a3);
	abstract void setGun0(int a0, int a1, int a2, int a3);
	abstract void setGun1(int a0, int a1, int a2, int a3);
	abstract void setGun2(int a0, int a1, int a2, int a3);
	abstract void setGun3(int a0, int a1, int a2, int a3);
	abstract void tryFire(int a0, int a1, int a2, int a3);
	abstract void fireSuccess(int a0, int a1, int a2, int a3);
	abstract void tryReload(int a0, int a1, int a2, int a3);
	abstract void reloadSuccess(int a0, int a1, int a2, int a3);
	abstract void setAmmo(int a0, int a1, int a2, int a3);
	abstract void setActive(int a0, int a1, int a2, int a3);
	abstract void noLives(int a0, int a1, int a2, int a3);
	abstract void hitBy(int a0, int a1, int a2, int a3);
	abstract void killedBy(int a0, int a1, int a2, int a3);
	abstract void setStartTime(int a0, int a1, int a2, int a3);
	abstract void setEndTime(int a0, int a1, int a2, int a3);
	abstract void endGame(int a0, int a1, int a2, int a3);
	abstract void ack(int a0, int a1, int a2, int a3);
	abstract void flush(int a0, int a1, int a2, int a3);
	
/* AUTO CODE END */

	

    public SerialManager(Context ctx){
        this.ctx = ctx;
    }

    public void addDataCallback(byte[] data){
        // Add the data
        for (byte b: data){
            if (FLUSH_SERIAL.equals(b))
                inBuffer.clear();
            else
                inBuffer.addLast(b);
        }

        parseMessages();

    }

    private boolean parseMessages(){
        SerialMessage startCode;
        byte[] packet;
        while (!inBuffer.isEmpty()){

            // Check the first byte to see if it's a message
            startCode = SerialMessage.getFromByte(inBuffer.peek());

            if (startCode == null){
                // Not a known message
                // Todo: Throw an exception and flush buffer
                return false;
            }

            switch (startCode){
				/* Generate Code like this:
                case SET_ACTIVE:
                    packet = parsePacket(4);
                    if (packet==null)
                        return false; //Queue not empty
                    setActive(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
                    break;
				*/
				
				
/* AUTO CODE BEGIN */

				case SET_STATE:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setState(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_LIVES:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setLives(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_SHIELD:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setShield(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_RESPAWN:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setRespawn(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_PID:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setPid(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_TID:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setTid(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_GID:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setGid(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_COLOR:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setColor(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case ADD_ENEMY:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					addEnemy(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case CLEAR_ENEMIES:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					clearEnemies(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_NUM_GUNS:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setNumGuns(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_GUN_0:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setGun0(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_GUN_1:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setGun1(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_GUN_2:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setGun2(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_GUN_3:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setGun3(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case TRY_FIRE:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					tryFire(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case FIRE_SUCCESS:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					fireSuccess(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case TRY_RELOAD:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					tryReload(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case RELOAD_SUCCESS:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					reloadSuccess(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_AMMO:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setAmmo(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_ACTIVE:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setActive(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case NO_LIVES:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					noLives(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case HIT_BY:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					hitBy(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case KILLED_BY:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					killedBy(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_START_TIME:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setStartTime(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case SET_END_TIME:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setEndTime(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case END_GAME:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					endGame(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case ACK:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					ack(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case FLUSH:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					flush(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				
/* AUTO CODE END */




                default:
                    return false;
            }


        }
        return true; //Queue is empty
    }

    private byte[] parsePacket(int num){
        if (inBuffer.size()>=num) {
            byte[] data = new byte[num];

            for (int i = 0; i < num; i++)
                data[i] = inBuffer.removeFirst();
            return data;
        } else {
            return null; // Not enough data, return null
        }
    }

    private int toInt(byte b){
        return (int) b & 0xFF;
    }


}
