/*
--------------------------------------------------------------------
XXXX           PYTEMPLATE AUTOMATICALLY GENERATED FILE          XXXX

        version 0.01                                                
        Generated 2015-02-10 16:24:10.904000
        
XXXX    DO NOT EDIT THIS FILE                                   XXXX
--------------------------------------------------------------------
*/package evans.dave.androtag.app;

/**
 * Created by Dave on 09/02/2015.
 */


import android.content.Context;
import android.util.Log;
import android.widget.Toast;

import java.util.LinkedList;

import evans.dave.androtag.common.SerialMessage;

import static evans.dave.androtag.common.SerialMessage.*;

public abstract class SerialManager {

    private static LinkedList<Byte> inBuffer = new LinkedList<>();
    private static Context ctx;

	/* Generate code like this:
    abstract void setShield(int a0, int a1, int a2, int a3);
	*/
	
	
/* AUTO CODE BEGIN */

	abstract void setName(int a0, int a1, int a2, int a3);
	abstract void getName(int a0, int a1, int a2, int a3);
	
/* AUTO CODE END */

	

    public SerialManager(Context ctx){
        this.ctx = ctx;
    }

    public void addDataCallback(byte[] data){
        // Add the data
        for (byte b: data){
            if (FLUSH_SERIAL.equals(b))
                inBuffer.clear();
            else
                inBuffer.addLast(b);
        }

        parseMessages();

    }

    private boolean parseMessages(){
        SerialMessage startCode;
        byte[] packet;
        while (!inBuffer.isEmpty()){

            // Check the first byte to see if it's a message
            startCode = SerialMessage.getFromByte(inBuffer.peek());

            if (startCode == null){
                // Not a known message
                // Todo: Throw an exception and flush buffer
                return false;
            }

            switch (startCode){
				/* Generate Code like this:
                case SET_ACTIVE:
                    packet = parsePacket(4);
                    if (packet==null)
                        return false; //Queue not empty
                    setActive(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
                    break;
				*/
				
				
/* AUTO CODE BEGIN */

				case SET_NAME:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					setName(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				case GET_NAME:
					packet = parsePacket(4);
					if (packet == null) return false; //Queue not empty
					getName(toInt(packet[1]), toInt(packet[2]),toInt(packet[3]),toInd(packet[4]));
					break;
				
				
/* AUTO CODE END */




                default:
                    return false;
            }


        }
        return true; //Queue is empty
    }

    private byte[] parsePacket(int num){
        if (inBuffer.size()>=num) {
            byte[] data = new byte[num];

            for (int i = 0; i < num; i++)
                data[i] = inBuffer.removeFirst();
            return data;
        } else {
            return null; // Not enough data, return null
        }
    }

    private int toInt(byte b){
        return (int) b & 0xFF;
    }


}
